//
//  InAppPurchaseApplicationService.swift
//  Knowledge
//
//  Created by Aamir Suhial Mir on 02.09.20.
//  Copyright Â© 2020 AMBOSS GmbH. All rights reserved.
//

import DIKit

import Domain
import Networking
import StoreKit

/// @mockable
protocol InAppPurchaseApplicationServiceType: AnyObject, ApplicationService {
    var storeState: InAppPurchaseStoreState { get }

    func purchaseInfo() -> InAppPurchaseInfo
    func updateStoreState()
    func buyAndLink(completion: @escaping (Result<Void, InAppPurchaseApplicationServiceError>) -> Void)
    func restoreAndLink(completion: @escaping (Result<Void, InAppPurchaseApplicationServiceError>) -> Void)
    func link(completion: @escaping (Result<Void, InAppPurchaseApplicationServiceError>) -> Void)
    func completeAndLinkTransactions(completion: @escaping (Result<Void, InAppPurchaseApplicationServiceError>) -> Void)
    func updateProductMetadata(completion: @escaping (InAppPurchaseApplicationServiceError?) -> Void)
}

final class InAppPurchaseApplicationService: InAppPurchaseApplicationServiceType {

    func purchaseInfo() -> InAppPurchaseInfo {
        info
    }

    @Inject private static var monitor: Monitoring

    private(set) var storeState: InAppPurchaseStoreState = .loading {
        didSet {
            guard oldValue != storeState else { return }
            NotificationCenter.default.post(InAppPurchaseStateDidChangeNotification(oldValue: oldValue, newValue: storeState), sender: self)
        }
    }

    private var info = InAppPurchaseInfo() {
        didSet {
            let notification = InAppPurchaseInfoDidChangeNotification(oldValue: oldValue, newValue: info)
            NotificationCenter.default.post(notification, sender: self)
        }
    }

    // WORKAROUND:
    // This is not inside the "info" object since sourcery cant inport StoreKit into its autogenerated mock file
    // It always prepends "@testable" to it, which leads to build errors in the test target
    private var product: SKProduct?

    private let inAppPurchaseClient: MembershipAccessClient
    private let subscriptionClient: InAppPurchaseSubscriptionClient
    private let analyticsTracking: TrackingType
    private let storage: Storage

    init(inAppPurchaseClient: MembershipAccessClient = resolve(), subscriptionClient: InAppPurchaseSubscriptionClient, analyticsTracking: TrackingType = resolve(), storage: Storage = resolve(tag: .default)) {
        self.inAppPurchaseClient = inAppPurchaseClient
        self.subscriptionClient = subscriptionClient
        self.analyticsTracking = analyticsTracking
        self.storage = storage
    }

    func updateStoreState() {
        storeState = .loading

        inAppPurchaseClient.getAmbossSubscriptionState { [weak self] result in
            guard let self = self else { return }

            switch result {
            case .success(let inAppPurchaseOnlineAccessItem):
                self.info = self.info
                    .with(canPurchase: inAppPurchaseOnlineAccessItem.canPurchaseInAppSubscription)
                    .with(hasActiveIAPSubcription: inAppPurchaseOnlineAccessItem.hasActiveInAppSubscription)
                self.analyticsTracking.track(.iapAccessUpdated(info: self.info))

                self.subscriptionClient.fetchSubscriptionState { result in

                    switch result {
                    case .success(let subscriptionState):
                        self.info = self.info.with(subscriptionState: subscriptionState)

                        // We are doing this in order to update legacy data on the backend that
                        // did not yet have the country code, this was added in v2.20.0 ...
                        let wasUpdated = self.storage.get(for: .iapCountryCodeWasUpdated) ?? false
                        let shouldUpdateCountryCode = wasUpdated == false && subscriptionState == .subscribed
                        if shouldUpdateCountryCode {
                            self.linkIAP { result in
                                switch result {
                                case .success:
                                    break // -> user defaults value is updated in linkIAP()
                                case .failure(let error):
                                    self.analyticsTracking.track(.iapLinkFailed(info: self.info, errorMessage: error.localizedDescription))
                                }
                            }
                        }

                    case .failure: break
                    }

                    self.subscriptionClient.updateProductMetadata { result in
                        switch result {
                        case .success(let product):
                            self.product = product
                            self.info = self.info.with(hasProductMetadata: product != nil)
                            self.analyticsTracking.track(.iapProductMetaDataUpdateSucceeded(info: self.info))
                        case .failure(let error):
                            self.analyticsTracking.track(.iapProductMetaDataUpdateFailed(info: self.info, errorMessage: error.localizedDescription))
                        }

                        self.storeState = self.storeStateProperty(canPurchase: self.info.canPurchase,
                                                                  hasActiveSubscription: self.info.hasActiveIAPSubscription,
                                                                  subscriptionState: self.info.subscriptionState,
                                                                  product: self.product)

                        self.inAppPurchaseClient.getHasTrialAccess { result in
                            var hasTrialAccess = false
                            switch result {
                            case .success(let hasAccess): hasTrialAccess = hasAccess
                            case .failure: break
                            }
                            self.info = self.info.with(hasTrialAccess: hasTrialAccess)
                        }
                    }
                }

            case .failure(let error):
                self.analyticsTracking.track(.iapAccessUpdateFailed(info: self.info, errorMessage: error.body))
            }
        }
    }

    func updateProductMetadata(completion: @escaping (InAppPurchaseApplicationServiceError?) -> Void) {
        subscriptionClient.updateProductMetadata { [weak self] result in
            guard let self = self else { return }
            switch result {
            case .success(nil): completion(.internalError("SKProduct is nil"))
            case .success(let product):
                self.product = product
                self.info = self.info.with(hasProductMetadata: product != nil)
                completion(nil)
            case .failure(let error): completion(error)
            }
        }
    }

    func buyAndLink(completion: @escaping (Result<Void, InAppPurchaseApplicationServiceError>) -> Void) {
        let originalStoreState = storeState
        storeState = .loading
        analyticsTracking.track(.iapSubscribeStarted(info: self.info))

        subscriptionClient.purchaseProduct { [weak self] result in
            guard let self = self else { return }

            switch result {
            case .success(let transaction):
                self.storeState = .unlinkedInAppPurchaseSubscription
                self.analyticsTracking.track(.iapSubscribeSucceeded(info: self.info))
                self.linkIAP(transaction: transaction, completion: completion)
            case .failure(let error):
                self.storeState = originalStoreState
                if case let InAppPurchaseApplicationServiceError.storeError(error) = error, error.code == .paymentCancelled {
                    self.analyticsTracking.track(.iapSubscribeCancelled(info: self.info))
                } else {
                    self.analyticsTracking.track(.iapSubscribeFailed(info: self.info, errorMessage: error.localizedDescription))
                }
                completion(.failure(error))
            }
        }
    }

    func restoreAndLink(completion: @escaping (Result<Void, InAppPurchaseApplicationServiceError>) -> Void) {
        let originalStoreState = storeState
        storeState = .loading
        analyticsTracking.track(.iapRestoreStarted(info: self.info))

        subscriptionClient.restorePurchases { [weak self] result in
            guard let self = self else { return }
            switch result {
            case .success(nil):
                self.storeState = originalStoreState
                self.analyticsTracking.track(.iapRestoreSucceeded(info: self.info))
                completion(.success(()))
            case .success(let transaction):
                self.storeState = .unlinkedInAppPurchaseSubscription
                self.analyticsTracking.track(.iapRestoreSucceeded(info: self.info))
                self.linkIAP(transaction: transaction, completion: completion)
            case .failure(let error):
                self.storeState = originalStoreState
                if case let InAppPurchaseApplicationServiceError.storeError(error) = error, error.code == .paymentCancelled {
                    self.analyticsTracking.track(.iapRestoreCancelled(info: self.info))
                } else {
                    self.analyticsTracking.track(.iapRestoreFailed(info: self.info, errorMessage: error.localizedDescription))
                }
                completion(.failure(error))
            }
        }
    }

    func completeAndLinkTransactions(completion: @escaping (Result<Void, InAppPurchaseApplicationServiceError>) -> Void) {
        storeState = .loading

        subscriptionClient.completeTransactions { [weak self] transaction in
            guard let self = self else { return }

            guard let transaction = transaction else { return completion(.success(())) }

            self.storeState = .unlinkedInAppPurchaseSubscription
            self.linkIAP(transaction: transaction, completion: completion)
        }
    }

    func link(completion: @escaping (Result<Void, InAppPurchaseApplicationServiceError>) -> Void) {
        linkIAP(completion: completion)
    }
}

extension InAppPurchaseApplicationService: ApplicationService {
    func application(_ application: UIApplicationType, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        completeAndLinkTransactions { _ in }
        return true
    }
}

private extension InAppPurchaseApplicationService {

    func linkIAP(transaction: SKPaymentTransaction? = nil, completion: @escaping (Result<Void, InAppPurchaseApplicationServiceError>) -> Void) {
        analyticsTracking.track(.iapLinkStarted(info: info))

        guard let receiptData = subscriptionClient.localReceiptData else {
            let errorMessage = "No receipt found"
            analyticsTracking.track(.iapLinkFailed(info: self.info, errorMessage: errorMessage))
            return completion(.failure(.internalError(errorMessage)))
        }

        storeState = .loading
        let countryCode = SKPaymentQueue.default().storefront?.countryCode ?? "unknown"
        inAppPurchaseClient.uploadInAppPurchaseSubscriptionReceipt(receiptData: receiptData, countryCode: countryCode) { [weak self] result in
            guard let self = self else { return }

            switch result {
            case .success:
                self.storeState = .activeInAppPurchaseSubscription
                self.analyticsTracking.track(.iapLinkSucceeded(info: self.info))
                if let transaction = transaction {
                    self.subscriptionClient.finishTransaction(transaction)
                }
                self.storage.store(true, for: .iapCountryCodeWasUpdated)
                return completion(.success(()))
            case .failure(let error):
                self.storeState = .unlinkedInAppPurchaseSubscription
                self.analyticsTracking.track(.iapLinkFailed(info: self.info, errorMessage: error.localizedDescription))

                return completion(.failure(.other(error)))
            }
        }
    }

    func storeStateProperty(canPurchase: Bool, hasActiveSubscription: Bool, subscriptionState: InAppPurchaseSubscriptionState, product: SKProduct?) -> InAppPurchaseStoreState {

        Self.monitor.info("canPurchase: \(canPurchase), hasActiveSubscripton: \(hasActiveSubscription), subscriptionState: \(subscriptionState), product: \(product?.description ?? "") ", context: .inAppPurchase)

        switch (canPurchase, hasActiveSubscription, subscriptionState, product) {
        case (false, true, .subscribed, _): return .activeInAppPurchaseSubscription
        case (false, false, .subscribed, _): return .permanentError
        case (false, false, .unsubscribed, _): return .activeExternalSubscription
        case (false, true, .unsubscribed, _): return .activeInAppPurchaseSubscription
        case (true, true, .subscribed, _): return .activeInAppPurchaseSubscription
        case (true, false, .subscribed, _): return .unlinkedInAppPurchaseSubscription
        case (true, true, .unsubscribed, _): return .temporaryError
        case (true, false, .unsubscribed, nil): return .temporaryError
        case (true, false, .unsubscribed, let product?): return .readyToBuy(product)
        case (false, false, .unknown, _): return .activeExternalSubscription
        case (false, true, .unknown, nil): return .temporaryError
        case (false, true, .unknown, let product?): return .readyToBuy(product)
        case (true, false, .unknown, nil): return .temporaryError
        case (true, false, .unknown, let product?): return .readyToBuy(product)
        case (true, true, .unknown, _): return .temporaryError
        }
    }
}
